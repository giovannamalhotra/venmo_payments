import scala.io.Source
import org.json4s._  // Used to parse json string from input file to object
import org.json4s.native.JsonMethods._ // Use to parse json string from input file to object
import scala.collection.mutable.ArrayBuffer // To create a mutable array that can grow in size
import com.github.nscala_time.time.Imports._  // Scala date time library
import java.io._

/** --------------------------  Summary of the program steps ---------------------------------------------------

  * 1. Validate input and output file names parameters
  *   a. Validate input and output file names were given when running the program (this are given in run.sh script)
  *   b. Validate input file exists. (Outfile existence is not validated as it will be generated by the program
  *
  * 2. Read transaction line from input File. Create transaction object and pass it to "processTransaction" method
  *
  * 3. Inside processTransaction method:
  *   a. Determine new max time stamp
  *   b. Add new transaction to array of last transactions
  *   c. Loop through all transactions and only consider the ones that are within the 60-seconds window (from latest time stamp)
  *   d. If transaction is within the 60 second-window, then copy it to temporary array and update number of connections for the actor and target
  *   e. Copy HasMap (containing number of connections for each individual) to Array, sort and calculate new median degree
  *   f. Write new median degree to output file
  */


/** ------------------------------------------------------------------- */
/** Class for mapping the transaction line received in input file */
/** ------------------------------------------------------------------- */
case class transaction(created_time: String, target: String, actor: String)


/** ------------------------------------------------------------------- */
/**     MEDIA-DEGREE program                                            */
/** ------------------------------------------------------------------- */
object media_degree {

  var transactionsArr = ArrayBuffer[transaction]()  /** empty array that holds all transactionObjects */
  var maxTimeStamp:Option[DateTime] = None  /** holds the maximum payment transaction timestamp */

  /** ------------------------------------------------------------------- */
  /**  Method to calculate the median of an ArrayBuffer of Int values     */
  /** ------------------------------------------------------------------- */
  def median(arr: ArrayBuffer[Int]): Double = {

    var middle = arr.length/2
    var result: Double = 0
    if (arr.length % 2 != 0) {  /** Array length is odd */

        result = arr(Math.floor(middle).toInt)
        result = BigDecimal(result).setScale(2, BigDecimal.RoundingMode.HALF_UP).toDouble
    }
    else { /**  middle is even */
      result = (arr(middle - 1).toDouble + arr(middle).toDouble) / 2
      //println("Inside median method - arr(middle - 1):" + arr(middle - 1) + ", arr(middle):" + arr(middle) + ", result:" + result)
      result = BigDecimal(result).setScale(2, BigDecimal.RoundingMode.HALF_UP).toDouble
    }
    return result
  }


  /** ------------------------------------------------------------------- */
  /**  Stand alone function to process a transaction. Called from "main"  */
  /** ------------------------------------------------------------------- */
  def processTransaction(o: transaction, outputFile: File): Unit = {


    /** Convert transaction created_time (String) to nscala-time DateTime */
    var transTime = DateTime.parse(o.created_time)

    var newMaxTimeStamp = maxTimeStamp

    /** Determine max timestamp */
    if (newMaxTimeStamp.isEmpty) {
      newMaxTimeStamp = Some(transTime)
    } else {

      if (transTime > newMaxTimeStamp.get ) {
        newMaxTimeStamp = Some(transTime)
      }
    }

    //println("----------------------------------------------------------------")
    //println("Process Transaction: a.target:" + o.target + ", a.actor:" + o.actor + ", o.created_time:" + o.created_time + ", transTime:" + transTime + ", newMaxTimeStamp:" + newMaxTimeStamp)
    //println("newMaxTimeStamp.get:" + newMaxTimeStamp.get + ", newMaxTimeStamp.get - 60.seconds:" + (newMaxTimeStamp.get - 60.seconds).toString  )

    /** Add transaction object to array of transactions  */
    transactionsArr += o

    /** create an empty map to keep track of connections for each vertex (actor or target) */
    var vertexMap = scala.collection.mutable.Map[String, Int]()

    /** Loop through last transactions, only consider the ones that are within the 60-seconds window */
    var transTempArr = ArrayBuffer[transaction]()
    for( a <- transactionsArr ){

      var lineTransTime = DateTime.parse(a.created_time)
      //println("a.target:" + a.target + ", a.actor:" + a.actor + ", a.created_time:" + a.created_time + ", lineTransTime:" + lineTransTime)

      if (lineTransTime > newMaxTimeStamp.get - 60.seconds) {
        /** Transaction time is within 60-secs window, then copy it to temporary array */
        transTempArr += a
        //println("Transaction will be copied")

        /** Increment connections for the transaction actor */
        if ( vertexMap.contains(a.actor) ) { /** If Vertex already exists in the HashMap, then increment its connections */
          vertexMap(a.actor) += 1
        }
        else {
          vertexMap += (a.actor -> 1)
        }

        /** Increment connections for the transaction target */
        if ( vertexMap.contains(a.target) ) { /** If Vertex already exists in the HashMap, then increment its connections */
          vertexMap(a.target) += 1
        }
        else {
          vertexMap += (a.target -> 1)
        }
      }
    }


    /** Copy HasMap (containing number of connections for each individual) to Array, sort and calculate new median degree */
    var medianArray = ArrayBuffer[Int]()
    for ((k,v) <- vertexMap) {
      medianArray += v
    }
    medianArray = medianArray.sorted
    //var medianValStr = median(medianArray).toString
    var medianValStr = "%.2f".format(median(medianArray)).toString

    /** Write new media degree to output file */
    //println("medianArray:" + medianArray + ", map:" + vertexMap)
    println("MEDIAN: " + medianValStr)
    val write = new PrintWriter(new FileOutputStream(outputFile,true))
    write.write(medianValStr + "\n")
    write.close()


    /** Update maxTimeStamp */
    maxTimeStamp = newMaxTimeStamp

    /** Update transactions array */
    transactionsArr = transTempArr

  }


  /** ------------------------------------------------------------------- */
  /**  MAIN procedure                                                     */
  /** ------------------------------------------------------------------- */
  def main(args: Array[String]): Unit = {

    /** Capture parameters for input and output files */
    //val inputFileName = "../venmo_input/venmo-trans.txt"
    //val outputFileName = "../venmo_output/output.txt"
    var inputFileName = ""
    var outputFileName = ""

    /** -------------------------------------------- */
    /** Validate file names were given as parameters */
    /** -------------------------------------------- */

    if (args.length <= 0) {
      println("----------------------------")
      println("MISSING PARAMETERS - Please provide Input and Output file names as parameters")
      println("----------------------------")
      return
    }

    if (args.length == 1) {
      println("----------------------------")
      println("MISSING PARAMETER - Please provide second parameter as the Output file name")
      println("----------------------------")
      return
    }

    if (args.length >= 2) {

      inputFileName = args(0)
      outputFileName = args(1)

      if (!new java.io.File(inputFileName).exists) {

        println("----------------------------")
        println("MISSING INPUT FILE - Input File '" + inputFileName + "' was not found")
        println("----------------------------")
        return
      }

    }


    //println("inputFileName:" + inputFileName + ", outputFileName:" + outputFileName)
    implicit val formats = DefaultFormats

    /** Create output file */
    val outputFile = new File(outputFileName)

    val writerObj = new PrintWriter(outputFile)
    writerObj.close()

    /** this variable will store the transaction line that is being processed */
    var transactionObject = new transaction("","","")

    /** Get transactions line by line */
    for (line <- Source.fromFile(inputFileName).getLines) {
      transactionObject = parse(line).extract[transaction]

      processTransaction(transactionObject, outputFile)

    }

  }
}